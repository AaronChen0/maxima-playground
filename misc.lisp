(in-package :maxima)

(defun number-of-digits (n)
  (check-type n unsigned-byte)
  (when (= n 0) (return-from number-of-digits 1))
  (let* ((i (floor (integer-length n) #.(log 10d0 2d0)))
         (num (expt 10 i)))
    (loop while (> num n) do (setf num (floor num 10) i (- i 1)))
    (loop while (<= num n) do (setf num (* num 10) i (+ i 1)))
    i))

(defmfun $nod (n)
  (number-of-digits n))

(defun nd (n)
  (check-type n unsigned-byte)
  (when (= n 0) (return-from nd 1))
  (let* ((i (round (log n 10d0)))
         (num (expt 10 i)))
    (if (>= n num) (1+ i) i)))

#+sbcl
(defmfun $khinchin (prec)
  (with-output-to-string (str)
    (sb-ext:run-program "/usr/bin/python"
                        (list "-c" (concatenate 'string "from flint import *;showgood(arb.const_khinchin,dps=" (write-to-string prec) ")"))
                        :output str)))

#+sbcl
(defmfun $glaisher (prec)
  (with-output-to-string (str)
    (sb-ext:run-program "/usr/bin/python"
                        (list "-c" (concatenate 'string "from flint import *;showgood(arb.const_glaisher,dps=" (write-to-string prec) ")"))
                        :output str)))

(defvar *cancelled)
(defun fpround (l &aux (*print-base* 10.) *print-radix*)
  (prog (adjust)
     (cond
       ((null *decfp)
	;;*M will be positive if the precision of the argument is greater than
	;;the current precision being used.
	(setq *m (- (integer-length l) fpprec))
	(when (= *m 0)
	  (setq *cancelled 0)
	  (return l))
	;;FPSHIFT is essentially LSH.
	(setq adjust (fpshift 1 (1- *m)))
	(when (minusp l) (setq adjust (- adjust)))
	(incf l adjust)
	(setq *m (- (integer-length l) fpprec))
	(setq *cancelled (abs *m))
	(cond ((zerop (hipart l (- *m)))
					;ONLY ZEROES SHIFTED OFF
	       (return (fpshift (fpshift l (- -1 *m))
				1)))	; ROUND TO MAKE EVEN
	      (t (return (fpshift l (- *m))))))
       (t
	(setq *m (- (number-of-digits (abs l)) fpprec))
	(setq adjust (fpshift 1 (1- *m)))
	(when (minusp l) (setq adjust (- adjust)))
	(setq adjust (* 5 adjust))
	(setq *m (- (number-of-digits (abs (setq l (+ l adjust)))) fpprec))
	(return (fpshift l (- *m)))))))

(defmfun $bfloat (x)
  (let (y)
    (cond ((bigfloatp x))
	  ((or (numberp x)
	       (member x '($%e $%pi $%gamma) :test #'eq))
	   (bcons (intofp x)))
          ((eq x '$%g) (fpcatalan))
	  ((or (atom x) (member 'array (cdar x) :test #'eq))
	   (if (eq x '$%phi)
	       ($bfloat '((mtimes simp)
			  ((rat simp) 1 2)
			  ((mplus simp) 1 ((mexpt simp) 5 ((rat simp) 1 2)))))
	       x))
          ((and (eq (caar x) '%zeta) (eq (cadr x) 3)) (fpzeta3))
          ((and (eq (caar x) '%zeta) (integerp (cadr x))
                (> (cadr x) 3) (oddp (cadr x)))
           (fpzeta (cadr x)))
          ((and (eq (caar x) '%zeta) (integerp (cadr x)) (> (cadr x) fpprec))
           ($bfloat 1))
	  ((eq (caar x) 'mexpt)
	   (if (equal (cadr x) '$%e)
	       (if (and (ratnump (caddr x))
                        (< 0 (second (caddr x)) (third (caddr x))))
                   (fpexp_rat (caddr x)) (*fpexp ($bfloat (caddr x))))
	       (exptbigfloat ($bfloat (cadr x)) (caddr x))))
	  ((eq (caar x) 'mncexpt)
	   (list '(mncexpt) ($bfloat (cadr x)) (caddr x)))
          ((and (eq (caar x) '%log) (integerp (cadr x)) (> (cadr x) 0))
           (bcons (log-n (cadr x))))
	  ((eq (caar x) 'rat)
	   (ratbigfloat (cdr x)))
	  ((setq y (safe-get (caar x) 'floatprog))
	   (funcall y (mapcar #'$bfloat (cdr x))))
	  ((or (trigp (caar x)) (arcp (caar x)) (eq (caar x) '$entier))
	   (setq y ($bfloat (cadr x)))
	   (if ($bfloatp y)
	       (cond ((eq (caar x) '$entier) ($entier y))
		     ((arcp (caar x))
		      (setq y ($bfloat (logarc (caar x) y)))
		      (if (free y '$%i)
			  y (let ($ratprint) (fparcsimp ($rectform y)))))
		     ((member (caar x) '(%cot %sec %csc) :test #'eq)
		      (invertbigfloat
		       ($bfloat (list (ncons (safe-get (caar x) 'recip)) y))))
		     (t ($bfloat (exponentialize (caar x) y))))
	       (subst0 (list (ncons (caar x)) y) x)))
	  (t (recur-apply #'$bfloat x)))))

(defun displa (form &aux #+kcl(form form))
  (if (not $ttyoff)
      (cond ($display2d
	     (cond (*alt-display2d* (apply *alt-display2d* form ()))
                   ((and (consp form) (consp (car form))
                         (eq (caar form) 'mlabel)
                         (integerp (third form)))
                    (format t "(~A) " (string-downcase (subseq (string (second form)) 1)))
                    (format t "~d~%" (third form)))
                   ((and (consp form) (consp (car form))
                         (eq (caar form) 'mlabel)
                         ($bfloatp (third form))
                         (< (abs (- (integer-length (second (third form))) (bigfloat-prec (third form)) (third (third form)))) 10))
                    (format t "(~A) " (string-downcase (subseq (string (second form)) 1)))
                    ($printf t "~h~%" (third form)))
                   ((and (consp form) (consp (car form))
                         (eq (caar form) 'mlabel)
                         (stringp (third form)))
                    (format t "(~A) " (string-downcase (subseq (string (second form)) 1)))
                    (format t "~s" (third form)))
		   (t
		    (let ((displayp t)
			  (linearray (if displayp
					 (make-array 80. :initial-element nil)
					 linearray))
			  (mratp (checkrat form))
			  (maxht     1) (maxdp   0) (width   0)
			  (height    0) (depth   0) (level   0) (size   2)
			  (break     0) (right   0) (lines   1) bkpt
			  (bkptwd    0) (bkptht  1) (bkptdp  0) (bkptout 0)
			  (bkptlevel 0) in-p)
		      (unwind-protect
			   (progn
			     (setq form (dimension form nil 'mparen 'mparen 0 0))
			     (checkbreak form width)
			     (output form (if (and (not $leftjust) (= 2 lines))
					      (- linel (- width bkptout))
					      0)))
			;; make sure the linearray gets cleared out.
			(fill linearray nil))))))
	    (t
	     (if *alt-display1d*
		 (apply *alt-display1d* form ())
		 (linear-displa form))))))
